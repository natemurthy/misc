package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"strings"
	"time"
)

const (
	avroBoolean = "boolean"
	avroDouble  = "double"
	avroFloat   = "float"
	avroInt     = "int"
	avroLong    = "long"
	avroString  = "string"

	goBool    = "bool"
	goFloat32 = "float32"
	goFloat64 = "float64"
	goInt32   = "int32"
	goInt64   = "int64"
	goUint32  = "uint32"
	goUint64  = "uint64"
)

var (
	numerics = []string{avroInt, avroLong}
	decimal  = []string{avroFloat, avroDouble}
)

func getAvroTypeFromGoType(t string) string {
	switch t {
	case goBool:
		return avroBoolean
	case goFloat32:
		return avroFloat
	case goFloat64:
		return avroDouble
	case goInt32:
		return avroInt
	case goInt64:
		return avroLong
	case goUint32:
		return avroInt
	case goUint64:
		return avroLong
	default:
		return avroString
	}
}

func setDefault(avroType string) string {
	if avroType == avroBoolean {
		return "false"
	}

	for _, t := range numerics {
		if avroType == t {
			return "0"
		}
	}

	for _, t := range decimal {
		if avroType == t {
			return "0.0"
		}
	}

	return `""`
}

func main() {
	g := Generator{}

	// Print the header and package clause.
	g.Printf(
		"// DO NOT EDIT: code generated by 'jsoner' on %s\n",
		time.Now().UTC().String(),
	)
	g.Printf("\n")
	g.Printf("package %s", "main")
	g.Printf("\n")

	g.generate()

	src := g.format()
	ioutil.WriteFile("foo_avro.go", src, 0644)
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) generate() {
	name := "foo.go"
	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, name, nil, parser.ParseComments)
	if err != nil {
		panic(err)
		fmt.Printf("warning: parsing package %s: %s", name, err)
	}
	ast.Inspect(parsedFile, g.genDecl)
	//ast.Inspect(parsedFile, checkNode)
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		fmt.Printf("warning: internal error: invalid Go generated: %s", err)
		fmt.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) genDecl(node ast.Node) bool {

	decl, ok := node.(*ast.GenDecl)
	if !ok {
		return true
	}

	typeSpec := decl.Specs[0].(*ast.TypeSpec)
	structType := typeSpec.Type.(*ast.StructType)
	structName := typeSpec.Name.Name

	g.Printf("func (%s) AvroSchema() avro.Schema{\n", structName)
	g.Printf("        return `{\n")
	g.Printf("                \"type\": \"record\",\n")
	g.Printf("                \"name\": \"%s\",\n", structName)
	g.Printf("                \"fields\": [\n")

	for _, field := range structType.Fields.List {
		_name := strings.Split(field.Tag.Value, "\"")[1]
		_type := getAvroTypeFromGoType(field.Type.(*ast.Ident).Name)

		g.Printf(
			"\t\t\t{\"name\": \"%s\", \"type\": \"%s\", \"default\": %s},\n",
			_name,
			_type,
			setDefault(_type),
		)
	}

	g.Printf("                ]\n")
	g.Printf("        }`\n")
	g.Printf("}\n")

	return false
}
